/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery } from '@tanstack/react-query';

import type {
    CreateEncounterEncountersPostParams,
    CreatePatientPatientPostParams,
    CreateTokenAuthLoginPostParams,
    EncounterDetailResponse,
    GetEncountersEncountersGetParams,
    GetPatientsPatientGetParams,
    HTTPValidationError,
    PaginatedEncounterResponse,
    PaginatedPatientResponse,
    PatientDetailResponse,
    RegisterUserAuthRegisterPostParams,
    RootGet200,
    TokenResponse,
    UpdateEncounterEncountersEncounterIdPutParams,
    UpdatePatientPatientPatientIdPutParams,
    User,
} from './fetchers.schemas';

import { customInstance } from './instance';

/**
 * Create token for the user
 * @summary Create Token
 */
export const createTokenAuthLoginPost = (
    params: CreateTokenAuthLoginPostParams,
    signal?: AbortSignal,
) => {
    return customInstance<TokenResponse>({
        url: `/auth/login/`,
        method: 'POST',
        params,
        signal,
    });
};

export const getCreateTokenAuthLoginPostMutationOptions = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createTokenAuthLoginPost>>,
        TError,
        { params: CreateTokenAuthLoginPostParams },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createTokenAuthLoginPost>>,
    TError,
    { params: CreateTokenAuthLoginPostParams },
    TContext
> => {
    const mutationKey = ['createTokenAuthLoginPost'];
    const { mutation: mutationOptions } = options
        ? options.mutation &&
          'mutationKey' in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createTokenAuthLoginPost>>,
        { params: CreateTokenAuthLoginPostParams }
    > = (props) => {
        const { params } = props ?? {};

        return createTokenAuthLoginPost(params);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateTokenAuthLoginPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof createTokenAuthLoginPost>>
>;

export type CreateTokenAuthLoginPostMutationError = void | HTTPValidationError;

/**
 * @summary Create Token
 */
export const useCreateTokenAuthLoginPost = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createTokenAuthLoginPost>>,
            TError,
            { params: CreateTokenAuthLoginPostParams },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createTokenAuthLoginPost>>,
    TError,
    { params: CreateTokenAuthLoginPostParams },
    TContext
> => {
    const mutationOptions = getCreateTokenAuthLoginPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Register a new user
 * @summary Register User
 */
export const registerUserAuthRegisterPost = (
    params: RegisterUserAuthRegisterPostParams,
    signal?: AbortSignal,
) => {
    return customInstance<TokenResponse>({
        url: `/auth/register`,
        method: 'POST',
        params,
        signal,
    });
};

export const getRegisterUserAuthRegisterPostMutationOptions = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
        TError,
        { params: RegisterUserAuthRegisterPostParams },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
    TError,
    { params: RegisterUserAuthRegisterPostParams },
    TContext
> => {
    const mutationKey = ['registerUserAuthRegisterPost'];
    const { mutation: mutationOptions } = options
        ? options.mutation &&
          'mutationKey' in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
        { params: RegisterUserAuthRegisterPostParams }
    > = (props) => {
        const { params } = props ?? {};

        return registerUserAuthRegisterPost(params);
    };

    return { mutationFn, ...mutationOptions };
};

export type RegisterUserAuthRegisterPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof registerUserAuthRegisterPost>>
>;

export type RegisterUserAuthRegisterPostMutationError =
    void | HTTPValidationError;

/**
 * @summary Register User
 */
export const useRegisterUserAuthRegisterPost = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
            TError,
            { params: RegisterUserAuthRegisterPostParams },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
    TError,
    { params: RegisterUserAuthRegisterPostParams },
    TContext
> => {
    const mutationOptions =
        getRegisterUserAuthRegisterPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Request profile info from logged in user
 * @summary Profile Information
 */
export const profileInformationAuthProfileGet = (signal?: AbortSignal) => {
    return customInstance<User>({
        url: `/auth/profile`,
        method: 'GET',
        signal,
    });
};

export const getProfileInformationAuthProfileGetQueryKey = () => {
    return [`/auth/profile`] as const;
};

export const getProfileInformationAuthProfileGetQueryOptions = <
    TData = Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
    TError = void,
>(options?: {
    query?: Partial<
        UseQueryOptions<
            Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
            TError,
            TData
        >
    >;
}) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getProfileInformationAuthProfileGetQueryKey();

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof profileInformationAuthProfileGet>>
    > = ({ signal }) => profileInformationAuthProfileGet(signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ProfileInformationAuthProfileGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof profileInformationAuthProfileGet>>
>;
export type ProfileInformationAuthProfileGetQueryError = void;

export function useProfileInformationAuthProfileGet<
    TData = Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
    TError = void,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof profileInformationAuthProfileGet>
                    >,
                    TError,
                    Awaited<ReturnType<typeof profileInformationAuthProfileGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProfileInformationAuthProfileGet<
    TData = Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
    TError = void,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof profileInformationAuthProfileGet>
                    >,
                    TError,
                    Awaited<ReturnType<typeof profileInformationAuthProfileGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProfileInformationAuthProfileGet<
    TData = Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
    TError = void,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Profile Information
 */

export function useProfileInformationAuthProfileGet<
    TData = Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
    TError = void,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof profileInformationAuthProfileGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions =
        getProfileInformationAuthProfileGetQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Get Encounters
 */
export const getEncountersEncountersGet = (
    params?: GetEncountersEncountersGetParams,
    signal?: AbortSignal,
) => {
    return customInstance<PaginatedEncounterResponse>({
        url: `/encounters/`,
        method: 'GET',
        params,
        signal,
    });
};

export const getGetEncountersEncountersGetQueryKey = (
    params?: GetEncountersEncountersGetParams,
) => {
    return [`/encounters/`, ...(params ? [params] : [])] as const;
};

export const getGetEncountersEncountersGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getEncountersEncountersGet>>,
    TError = void | HTTPValidationError,
>(
    params?: GetEncountersEncountersGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getEncountersEncountersGet>>,
                TError,
                TData
            >
        >;
    },
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetEncountersEncountersGetQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getEncountersEncountersGet>>
    > = ({ signal }) => getEncountersEncountersGet(params, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getEncountersEncountersGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEncountersEncountersGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getEncountersEncountersGet>>
>;
export type GetEncountersEncountersGetQueryError = void | HTTPValidationError;

export function useGetEncountersEncountersGet<
    TData = Awaited<ReturnType<typeof getEncountersEncountersGet>>,
    TError = void | HTTPValidationError,
>(
    params: undefined | GetEncountersEncountersGetParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getEncountersEncountersGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getEncountersEncountersGet>>,
                    TError,
                    Awaited<ReturnType<typeof getEncountersEncountersGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEncountersEncountersGet<
    TData = Awaited<ReturnType<typeof getEncountersEncountersGet>>,
    TError = void | HTTPValidationError,
>(
    params?: GetEncountersEncountersGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getEncountersEncountersGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getEncountersEncountersGet>>,
                    TError,
                    Awaited<ReturnType<typeof getEncountersEncountersGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEncountersEncountersGet<
    TData = Awaited<ReturnType<typeof getEncountersEncountersGet>>,
    TError = void | HTTPValidationError,
>(
    params?: GetEncountersEncountersGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getEncountersEncountersGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Encounters
 */

export function useGetEncountersEncountersGet<
    TData = Awaited<ReturnType<typeof getEncountersEncountersGet>>,
    TError = void | HTTPValidationError,
>(
    params?: GetEncountersEncountersGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getEncountersEncountersGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetEncountersEncountersGetQueryOptions(
        params,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Create Encounter
 */
export const createEncounterEncountersPost = (
    params: CreateEncounterEncountersPostParams,
    signal?: AbortSignal,
) => {
    return customInstance<EncounterDetailResponse>({
        url: `/encounters/`,
        method: 'POST',
        params,
        signal,
    });
};

export const getCreateEncounterEncountersPostMutationOptions = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createEncounterEncountersPost>>,
        TError,
        { params: CreateEncounterEncountersPostParams },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createEncounterEncountersPost>>,
    TError,
    { params: CreateEncounterEncountersPostParams },
    TContext
> => {
    const mutationKey = ['createEncounterEncountersPost'];
    const { mutation: mutationOptions } = options
        ? options.mutation &&
          'mutationKey' in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createEncounterEncountersPost>>,
        { params: CreateEncounterEncountersPostParams }
    > = (props) => {
        const { params } = props ?? {};

        return createEncounterEncountersPost(params);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateEncounterEncountersPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof createEncounterEncountersPost>>
>;

export type CreateEncounterEncountersPostMutationError =
    void | HTTPValidationError;

/**
 * @summary Create Encounter
 */
export const useCreateEncounterEncountersPost = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createEncounterEncountersPost>>,
            TError,
            { params: CreateEncounterEncountersPostParams },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createEncounterEncountersPost>>,
    TError,
    { params: CreateEncounterEncountersPostParams },
    TContext
> => {
    const mutationOptions =
        getCreateEncounterEncountersPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Encounter
 */
export const getEncounterEncountersEncounterIdGet = (
    encounterId: number,
    signal?: AbortSignal,
) => {
    return customInstance<EncounterDetailResponse>({
        url: `/encounters/${encounterId}`,
        method: 'GET',
        signal,
    });
};

export const getGetEncounterEncountersEncounterIdGetQueryKey = (
    encounterId?: number,
) => {
    return [`/encounters/${encounterId}`] as const;
};

export const getGetEncounterEncountersEncounterIdGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getEncounterEncountersEncounterIdGet>>,
    TError = void | HTTPValidationError,
>(
    encounterId: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof getEncounterEncountersEncounterIdGet>
                >,
                TError,
                TData
            >
        >;
    },
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetEncounterEncountersEncounterIdGetQueryKey(encounterId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getEncounterEncountersEncounterIdGet>>
    > = ({ signal }) =>
        getEncounterEncountersEncounterIdGet(encounterId, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!encounterId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getEncounterEncountersEncounterIdGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEncounterEncountersEncounterIdGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getEncounterEncountersEncounterIdGet>>
>;
export type GetEncounterEncountersEncounterIdGetQueryError =
    void | HTTPValidationError;

export function useGetEncounterEncountersEncounterIdGet<
    TData = Awaited<ReturnType<typeof getEncounterEncountersEncounterIdGet>>,
    TError = void | HTTPValidationError,
>(
    encounterId: number,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof getEncounterEncountersEncounterIdGet>
                >,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof getEncounterEncountersEncounterIdGet>
                    >,
                    TError,
                    Awaited<
                        ReturnType<typeof getEncounterEncountersEncounterIdGet>
                    >
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEncounterEncountersEncounterIdGet<
    TData = Awaited<ReturnType<typeof getEncounterEncountersEncounterIdGet>>,
    TError = void | HTTPValidationError,
>(
    encounterId: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof getEncounterEncountersEncounterIdGet>
                >,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<
                        ReturnType<typeof getEncounterEncountersEncounterIdGet>
                    >,
                    TError,
                    Awaited<
                        ReturnType<typeof getEncounterEncountersEncounterIdGet>
                    >
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEncounterEncountersEncounterIdGet<
    TData = Awaited<ReturnType<typeof getEncounterEncountersEncounterIdGet>>,
    TError = void | HTTPValidationError,
>(
    encounterId: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof getEncounterEncountersEncounterIdGet>
                >,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Encounter
 */

export function useGetEncounterEncountersEncounterIdGet<
    TData = Awaited<ReturnType<typeof getEncounterEncountersEncounterIdGet>>,
    TError = void | HTTPValidationError,
>(
    encounterId: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<
                    ReturnType<typeof getEncounterEncountersEncounterIdGet>
                >,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetEncounterEncountersEncounterIdGetQueryOptions(
        encounterId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Update Encounter
 */
export const updateEncounterEncountersEncounterIdPut = (
    encounterId: number,
    params: UpdateEncounterEncountersEncounterIdPutParams,
) => {
    return customInstance<EncounterDetailResponse>({
        url: `/encounters/${encounterId}`,
        method: 'PUT',
        params,
    });
};

export const getUpdateEncounterEncountersEncounterIdPutMutationOptions = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updateEncounterEncountersEncounterIdPut>>,
        TError,
        {
            encounterId: number;
            params: UpdateEncounterEncountersEncounterIdPutParams;
        },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updateEncounterEncountersEncounterIdPut>>,
    TError,
    {
        encounterId: number;
        params: UpdateEncounterEncountersEncounterIdPutParams;
    },
    TContext
> => {
    const mutationKey = ['updateEncounterEncountersEncounterIdPut'];
    const { mutation: mutationOptions } = options
        ? options.mutation &&
          'mutationKey' in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updateEncounterEncountersEncounterIdPut>>,
        {
            encounterId: number;
            params: UpdateEncounterEncountersEncounterIdPutParams;
        }
    > = (props) => {
        const { encounterId, params } = props ?? {};

        return updateEncounterEncountersEncounterIdPut(encounterId, params);
    };

    return { mutationFn, ...mutationOptions };
};

export type UpdateEncounterEncountersEncounterIdPutMutationResult = NonNullable<
    Awaited<ReturnType<typeof updateEncounterEncountersEncounterIdPut>>
>;

export type UpdateEncounterEncountersEncounterIdPutMutationError =
    void | HTTPValidationError;

/**
 * @summary Update Encounter
 */
export const useUpdateEncounterEncountersEncounterIdPut = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updateEncounterEncountersEncounterIdPut>>,
            TError,
            {
                encounterId: number;
                params: UpdateEncounterEncountersEncounterIdPutParams;
            },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof updateEncounterEncountersEncounterIdPut>>,
    TError,
    {
        encounterId: number;
        params: UpdateEncounterEncountersEncounterIdPutParams;
    },
    TContext
> => {
    const mutationOptions =
        getUpdateEncounterEncountersEncounterIdPutMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete Encounter
 */
export const deleteEncounterEncountersEncounterIdDelete = (
    encounterId: number,
) => {
    return customInstance<unknown>({
        url: `/encounters/${encounterId}`,
        method: 'DELETE',
    });
};

export const getDeleteEncounterEncountersEncounterIdDeleteMutationOptions = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deleteEncounterEncountersEncounterIdDelete>>,
        TError,
        { encounterId: number },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deleteEncounterEncountersEncounterIdDelete>>,
    TError,
    { encounterId: number },
    TContext
> => {
    const mutationKey = ['deleteEncounterEncountersEncounterIdDelete'];
    const { mutation: mutationOptions } = options
        ? options.mutation &&
          'mutationKey' in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deleteEncounterEncountersEncounterIdDelete>>,
        { encounterId: number }
    > = (props) => {
        const { encounterId } = props ?? {};

        return deleteEncounterEncountersEncounterIdDelete(encounterId);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeleteEncounterEncountersEncounterIdDeleteMutationResult =
    NonNullable<
        Awaited<ReturnType<typeof deleteEncounterEncountersEncounterIdDelete>>
    >;

export type DeleteEncounterEncountersEncounterIdDeleteMutationError =
    void | HTTPValidationError;

/**
 * @summary Delete Encounter
 */
export const useDeleteEncounterEncountersEncounterIdDelete = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<
                ReturnType<typeof deleteEncounterEncountersEncounterIdDelete>
            >,
            TError,
            { encounterId: number },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deleteEncounterEncountersEncounterIdDelete>>,
    TError,
    { encounterId: number },
    TContext
> => {
    const mutationOptions =
        getDeleteEncounterEncountersEncounterIdDeleteMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Patients
 */
export const getPatientsPatientGet = (
    params?: GetPatientsPatientGetParams,
    signal?: AbortSignal,
) => {
    return customInstance<PaginatedPatientResponse>({
        url: `/patient/`,
        method: 'GET',
        params,
        signal,
    });
};

export const getGetPatientsPatientGetQueryKey = (
    params?: GetPatientsPatientGetParams,
) => {
    return [`/patient/`, ...(params ? [params] : [])] as const;
};

export const getGetPatientsPatientGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getPatientsPatientGet>>,
    TError = void | HTTPValidationError,
>(
    params?: GetPatientsPatientGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientsPatientGet>>,
                TError,
                TData
            >
        >;
    },
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ?? getGetPatientsPatientGetQueryKey(params);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getPatientsPatientGet>>
    > = ({ signal }) => getPatientsPatientGet(params, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getPatientsPatientGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPatientsPatientGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getPatientsPatientGet>>
>;
export type GetPatientsPatientGetQueryError = void | HTTPValidationError;

export function useGetPatientsPatientGet<
    TData = Awaited<ReturnType<typeof getPatientsPatientGet>>,
    TError = void | HTTPValidationError,
>(
    params: undefined | GetPatientsPatientGetParams,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientsPatientGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPatientsPatientGet>>,
                    TError,
                    Awaited<ReturnType<typeof getPatientsPatientGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPatientsPatientGet<
    TData = Awaited<ReturnType<typeof getPatientsPatientGet>>,
    TError = void | HTTPValidationError,
>(
    params?: GetPatientsPatientGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientsPatientGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPatientsPatientGet>>,
                    TError,
                    Awaited<ReturnType<typeof getPatientsPatientGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPatientsPatientGet<
    TData = Awaited<ReturnType<typeof getPatientsPatientGet>>,
    TError = void | HTTPValidationError,
>(
    params?: GetPatientsPatientGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientsPatientGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Patients
 */

export function useGetPatientsPatientGet<
    TData = Awaited<ReturnType<typeof getPatientsPatientGet>>,
    TError = void | HTTPValidationError,
>(
    params?: GetPatientsPatientGetParams,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientsPatientGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetPatientsPatientGetQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Create Patient
 */
export const createPatientPatientPost = (
    params: CreatePatientPatientPostParams,
    signal?: AbortSignal,
) => {
    return customInstance<PatientDetailResponse>({
        url: `/patient/`,
        method: 'POST',
        params,
        signal,
    });
};

export const getCreatePatientPatientPostMutationOptions = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createPatientPatientPost>>,
        TError,
        { params: CreatePatientPatientPostParams },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createPatientPatientPost>>,
    TError,
    { params: CreatePatientPatientPostParams },
    TContext
> => {
    const mutationKey = ['createPatientPatientPost'];
    const { mutation: mutationOptions } = options
        ? options.mutation &&
          'mutationKey' in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createPatientPatientPost>>,
        { params: CreatePatientPatientPostParams }
    > = (props) => {
        const { params } = props ?? {};

        return createPatientPatientPost(params);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreatePatientPatientPostMutationResult = NonNullable<
    Awaited<ReturnType<typeof createPatientPatientPost>>
>;

export type CreatePatientPatientPostMutationError = void | HTTPValidationError;

/**
 * @summary Create Patient
 */
export const useCreatePatientPatientPost = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createPatientPatientPost>>,
            TError,
            { params: CreatePatientPatientPostParams },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createPatientPatientPost>>,
    TError,
    { params: CreatePatientPatientPostParams },
    TContext
> => {
    const mutationOptions = getCreatePatientPatientPostMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Patient
 */
export const getPatientPatientPatientIdGet = (
    patientId: number,
    signal?: AbortSignal,
) => {
    return customInstance<PatientDetailResponse>({
        url: `/patient/${patientId}`,
        method: 'GET',
        signal,
    });
};

export const getGetPatientPatientPatientIdGetQueryKey = (
    patientId?: number,
) => {
    return [`/patient/${patientId}`] as const;
};

export const getGetPatientPatientPatientIdGetQueryOptions = <
    TData = Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
    TError = void | HTTPValidationError,
>(
    patientId: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
                TError,
                TData
            >
        >;
    },
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
        queryOptions?.queryKey ??
        getGetPatientPatientPatientIdGetQueryKey(patientId);

    const queryFn: QueryFunction<
        Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>
    > = ({ signal }) => getPatientPatientPatientIdGet(patientId, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!patientId,
        ...queryOptions,
    } as UseQueryOptions<
        Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPatientPatientPatientIdGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>
>;
export type GetPatientPatientPatientIdGetQueryError =
    void | HTTPValidationError;

export function useGetPatientPatientPatientIdGet<
    TData = Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
    TError = void | HTTPValidationError,
>(
    patientId: number,
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPatientPatientPatientIdGet<
    TData = Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
    TError = void | HTTPValidationError,
>(
    patientId: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
                    TError,
                    Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPatientPatientPatientIdGet<
    TData = Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
    TError = void | HTTPValidationError,
>(
    patientId: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Patient
 */

export function useGetPatientPatientPatientIdGet<
    TData = Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
    TError = void | HTTPValidationError,
>(
    patientId: number,
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getPatientPatientPatientIdGet>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetPatientPatientPatientIdGetQueryOptions(
        patientId,
        options,
    );

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Update Patient
 */
export const updatePatientPatientPatientIdPut = (
    patientId: number,
    params: UpdatePatientPatientPatientIdPutParams,
) => {
    return customInstance<PatientDetailResponse>({
        url: `/patient/${patientId}`,
        method: 'PUT',
        params,
    });
};

export const getUpdatePatientPatientPatientIdPutMutationOptions = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof updatePatientPatientPatientIdPut>>,
        TError,
        { patientId: number; params: UpdatePatientPatientPatientIdPutParams },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof updatePatientPatientPatientIdPut>>,
    TError,
    { patientId: number; params: UpdatePatientPatientPatientIdPutParams },
    TContext
> => {
    const mutationKey = ['updatePatientPatientPatientIdPut'];
    const { mutation: mutationOptions } = options
        ? options.mutation &&
          'mutationKey' in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof updatePatientPatientPatientIdPut>>,
        { patientId: number; params: UpdatePatientPatientPatientIdPutParams }
    > = (props) => {
        const { patientId, params } = props ?? {};

        return updatePatientPatientPatientIdPut(patientId, params);
    };

    return { mutationFn, ...mutationOptions };
};

export type UpdatePatientPatientPatientIdPutMutationResult = NonNullable<
    Awaited<ReturnType<typeof updatePatientPatientPatientIdPut>>
>;

export type UpdatePatientPatientPatientIdPutMutationError =
    void | HTTPValidationError;

/**
 * @summary Update Patient
 */
export const useUpdatePatientPatientPatientIdPut = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof updatePatientPatientPatientIdPut>>,
            TError,
            {
                patientId: number;
                params: UpdatePatientPatientPatientIdPutParams;
            },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof updatePatientPatientPatientIdPut>>,
    TError,
    { patientId: number; params: UpdatePatientPatientPatientIdPutParams },
    TContext
> => {
    const mutationOptions =
        getUpdatePatientPatientPatientIdPutMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete Patient
 */
export const deletePatientPatientPatientIdDelete = (patientId: number) => {
    return customInstance<unknown>({
        url: `/patient/${patientId}`,
        method: 'DELETE',
    });
};

export const getDeletePatientPatientPatientIdDeleteMutationOptions = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof deletePatientPatientPatientIdDelete>>,
        TError,
        { patientId: number },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof deletePatientPatientPatientIdDelete>>,
    TError,
    { patientId: number },
    TContext
> => {
    const mutationKey = ['deletePatientPatientPatientIdDelete'];
    const { mutation: mutationOptions } = options
        ? options.mutation &&
          'mutationKey' in options.mutation &&
          options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof deletePatientPatientPatientIdDelete>>,
        { patientId: number }
    > = (props) => {
        const { patientId } = props ?? {};

        return deletePatientPatientPatientIdDelete(patientId);
    };

    return { mutationFn, ...mutationOptions };
};

export type DeletePatientPatientPatientIdDeleteMutationResult = NonNullable<
    Awaited<ReturnType<typeof deletePatientPatientPatientIdDelete>>
>;

export type DeletePatientPatientPatientIdDeleteMutationError =
    void | HTTPValidationError;

/**
 * @summary Delete Patient
 */
export const useDeletePatientPatientPatientIdDelete = <
    TError = void | HTTPValidationError,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof deletePatientPatientPatientIdDelete>>,
            TError,
            { patientId: number },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof deletePatientPatientPatientIdDelete>>,
    TError,
    { patientId: number },
    TContext
> => {
    const mutationOptions =
        getDeletePatientPatientPatientIdDeleteMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * Root endpoint to check if the API is running.
 * @summary Root
 */
export const rootGet = (signal?: AbortSignal) => {
    return customInstance<RootGet200>({ url: `/`, method: 'GET', signal });
};

export const getRootGetQueryKey = () => {
    return [`/`] as const;
};

export const getRootGetQueryOptions = <
    TData = Awaited<ReturnType<typeof rootGet>>,
    TError = unknown,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
    >;
}) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getRootGetQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({
        signal,
    }) => rootGet(signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof rootGet>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RootGetQueryResult = NonNullable<
    Awaited<ReturnType<typeof rootGet>>
>;
export type RootGetQueryError = unknown;

export function useRootGet<
    TData = Awaited<ReturnType<typeof rootGet>>,
    TError = unknown,
>(
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof rootGet>>,
                    TError,
                    Awaited<ReturnType<typeof rootGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRootGet<
    TData = Awaited<ReturnType<typeof rootGet>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof rootGet>>,
                    TError,
                    Awaited<ReturnType<typeof rootGet>>
                >,
                'initialData'
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRootGet<
    TData = Awaited<ReturnType<typeof rootGet>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Root
 */

export function useRootGet<
    TData = Awaited<ReturnType<typeof rootGet>>,
    TError = unknown,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getRootGetQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<
        TData,
        TError
    > & { queryKey: DataTag<QueryKey, TData, TError> };

    query.queryKey = queryOptions.queryKey;

    return query;
}
